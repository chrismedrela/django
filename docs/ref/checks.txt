.. module:: django.core.checks

.. _`system-check-framework`:

======================
System check framework
======================

System check framework is a set of static checks. It detects common problems
like invalid models or compatibility issues and report them providing hints.
The framework is open-ended, so you can easily add your own checks.

Checks can be triggered explicitly via :djadmin:`check` command. It's also
triggered implicitly before most commands, including :djadmin:`runserver` and
:djadmin:`migrate`. For performance issues, checks are not performed if
``DEBUG`` is set to ``False``.

Django will not allow you to run server if there is any serious message like
an error or critical error. If there are light messages like warnings, Django
won't stop you, but will issue the message. You can hide unwanted warnings or
force Django to run even if there are serious messages by overriding
:setting:`SILENCED_SYSTEM_CHECKS` setting.

Writing your own checks
=======================

The framework is flexible and allow you to write functions (or other callable
objects like methods) performing any kind of checks. The function has to receive
``**kwargs`` and return list of messages. At the end, the function need to be
`registered`_ or `called from another check`_.

.. _`registered`: `registering-checks`_
.. _`called from another check`: `field-checks`_

.. class:: django.core.checks.CheckMessage(level, msg, hint, obj=None, id=None)

:class:`~django.core.checks.CheckMessage` is the key concept of
:mod:`django.core.checks` module and represents a single message, i.e. a
warning or an error. The concept is very similar to messages from
:doc:`message framework </ref/contrib/messages>` or `logging framework`_.
Messages are tagged with ``level`` indicating how ses the message is. They
can have an unique identifier abbreviated ``id``.

.. _`logging framework`: http://docs.python.org/2/library/logging.html

Constructor arguments are:

``level``
    A positive integer. Determines how serious the message is. There are five
    predefined values: ``DEBUG``, ``INFO``, ``WARNING``, ``ERROR``,
    ``CRITICAL``. If the level is greater or equal to ``ERROR``, then Django
    stops everything and doesn't allow to i.e. run a server. Messages with level
    lower than ``ERROR`` (i.e. warnings) are still reported, but Django will not
    stop you. Both behaviours can be changed by manipulating
    :setting:`SILENCED_SYSTEM_CHECKS`.

``msg``
    A required single-line string describing the problem.

``hint``
    A single-line string or ``None`` if you cannot provide any hint. Note that
    you need to pass this argument explicitly even if you pass ``None``::

        Error('error message') # bad
        Error('error message', None) # good
        Error('error message', hint=None) # good (prable)

``obj``
    Optional. Point to the invalid object. The object should be a model, field
    or manager or any other object that defines ``__unicode__`` method (on
    Python 3 you need to define ``__str__`` method). The method is used while
    reporting all messages and its result precedes the message.

``id``
    Optional string. Short and unique name of an issue. Follow "applabel.X001"
    style, where ``X`` is one of ``CEWID`` letters depending on the message
    level (``C`` for critical errors, ``E`` for errors and so on), i.e. a warning
    may have ``applabel.W001`` id and an error can be ``applabel.E002``. The
    message number must be unique among an app, so ``applabel.E001`` and
    ``anotherapp.E001`` are OK. Do not reuse one number for more than one
    message, e.g. avoid ``applabel.E001`` and ``applabel.W001``.

There are shortcuts to make creating messages with common levels easier. You can
omit ``level`` argument because the level is indicated by the class name.

.. class:: django.core.checks.Debug(msg, hint, obj=None, id=None)
.. class:: django.core.checks.Info(msg, hint, obj=None, id=None)
.. class:: django.core.checks.Warning(msg, hint, obj=None, id=None)
.. class:: django.core.checks.Error(msg, hint, obj=None, id=None)
.. class:: django.core.checks.Critical(msg, hint, obj=None, id=None)

Messages are comparable. That allows you to easily write tests::

    from django.core.checks import Error
    errors = checked_object.check()
    expected_errors = [
        Error(
            'an error',
            hint=None,
            obj=checked_object,
            id='myapp.E001',
        )
    ]
    self.assertEqual(errors, expected_errors)

.. _`registering-checks`:

Registering and labeling checks
-------------------------------

Your check function need to be registered explicitly in system check framework
or `called from another function`_ that is registered directly or indirectly.

.. _`called from another function`: `field-checks`_

.. method:: register(*tags)(function)

Note that checks are performed just after loading apps and you need to register
them earlier. It's recommended to use ``register`` as a decorator of
module-level function so the function will be registered at the time of
importing the module.

You can pass as many tags to ``register`` as you want in order to label your
check. Tagging checks is useful since it allows you to run only a certain
group of checks, i.e. compatibility checks::

    from checks import register

    @register('compatibility')
    def my_check(apps, **kwargs):
        # ... perform compatibility checks and collect errors
        return errors

Note that registered checks not only have to take ``**kwargs`` and return list
of messages, they also accept ``apps`` argument. If ``apps`` is ``None``, all
apps should be checked, otherwise only the given set of apps should be
validated.

.. _field-checks:

Field checks
------------

You do not need to `register check function`_ if it's called from another check
function. It's easy in the case of fields, `manager checks`_ as well as `model
checks`_.

.. _`register check function`: `registering-checks`_
.. _`manager checks`: `manager-checks`_
.. _`model checks`: `model-checks`_

In case of fields, you need to override ``check`` method: it should call the
superclass (1), perform its own checks, which may end in new messages (2) and
eventually return list of all messages (3). It's recommended to delegate checks
to separated methods to keep ``check`` method short and simple.

Consider an example where you are implementing ``RangedIntegerField``. It
accepts ``min`` and ``max`` arguments in the constructor. You want to check if
``min`` value is smaller or equal to ``max`` value. Here is a snippet of code
showing how you can implement this check::

    from django.core import checks
    from django.db import models

    class RangedIntegerField(models.IntegerField):
        def __init__(self, min, max, **kwargs):
            super(RangedIntegerField, self).__init__(**kwargs)
            self.min = min
            self.max = max

        def check(self, **kwargs):
            errors = super(RangedIntegerField, self).check(**kwargs) # (1) call the superclass
            # (2) Do some custom checks and add messages to `errors`:
            errors.extend(self._check_min_max_values(**kwargs))
            return errors # (3) return all messages

        def _check_min_max_values(self, **kwargs):
            if self.min > self.max:
                return [
                    checks.Error(
                        'min greated than max.',
                        hint='Lower min or upper max.',
                        obj=self,
                        id='myapp.E001',
                    )
                ]
            else:
                return [] # When no error, return an empty list

Database backend specific checks are performed in
``DatabaseValidation.check_field`` method. The API of ``DatabaseValidation``
is not formally stable and may change in the future.

.. _manager-checks:

Manager checks
--------------

Manager checks are very similar to :ref:`field checks <field-checks>`. The only
difference is that your class needs to inherit from ``models.Manager``.

.. _model-checks:

Model checks
------------

It's possible to check Model classes. Note that the framework verifies the
class, not it's instances. It works exactly in the same way as `field checks`_
except that you need to use classmethods::

    class MyModel(models.Model):
        @classmethod
        def check(cls, **kwargs):
            errors = super(MyModel, cls).check(**kwargs)
            # ... your own checks ...
            return errors

.. _`field checks`: `field-checks`_
